{
  "patches": {
    "@/example": {
      "nodes": {
        "BymvHVDF9": {
          "boundLiterals": {
            "BkBqXCKFq": "On Boot"
          },
          "id": "BymvHVDF9",
          "position": {
            "x": -6,
            "y": 1,
            "units": "slots"
          },
          "type": "@/operatinghourscounter"
        },
        "S1b5BNwK9": {
          "boundLiterals": {
            "Sk1e_NIVE": "False"
          },
          "id": "S1b5BNwK9",
          "position": {
            "x": -6,
            "y": 0,
            "units": "slots"
          },
          "type": "xod/debug/tweak-boolean"
        },
        "r1z8RNDYc": {
          "id": "r1z8RNDYc",
          "position": {
            "x": -3,
            "y": 3,
            "units": "slots"
          },
          "type": "xod/debug/watch"
        },
        "rkXs9Hwtc": {
          "id": "rkXs9Hwtc",
          "position": {
            "x": -4,
            "y": 3,
            "units": "slots"
          },
          "type": "xod/debug/watch"
        },
        "ByBUawvK9": {
          "boundLiterals": {
            "ByfGSDjQE": "0"
          },
          "id": "ByBUawvK9",
          "position": {
            "x": -5,
            "y": 0,
            "units": "slots"
          },
          "type": "xod/debug/tweak-number"
        },
        "S14ls_DY5": {
          "id": "S14ls_DY5",
          "position": {
            "x": -5,
            "y": 3,
            "units": "slots"
          },
          "type": "xod/debug/watch"
        },
        "ryJ4KCttq": {
          "boundLiterals": {
            "ByfGSDjQE": "0"
          },
          "id": "ryJ4KCttq",
          "position": {
            "x": -4,
            "y": 0,
            "units": "slots"
          },
          "type": "xod/debug/tweak-number"
        },
        "Byrk2ecYc": {
          "id": "Byrk2ecYc",
          "position": {
            "x": -6,
            "y": 3,
            "units": "slots"
          },
          "type": "xod/debug/watch"
        },
        "ry0Aksntc": {
          "boundLiterals": {
            "Sk1e_NIVE": "True"
          },
          "id": "ry0Aksntc",
          "position": {
            "x": -3,
            "y": 0,
            "units": "slots"
          },
          "type": "xod/debug/tweak-boolean"
        },
        "B1Z_Pn3tq": {
          "id": "B1Z_Pn3tq",
          "position": {
            "x": 0,
            "y": 6,
            "units": "slots"
          },
          "type": "xod/core/count"
        },
        "BJLyWBe5c": {
          "id": "BJLyWBe5c",
          "position": {
            "x": -2,
            "y": 0,
            "units": "slots"
          },
          "type": "xod/debug/tweak-pulse"
        }
      },
      "links": {
        "SyzqrVDKq": {
          "id": "SyzqrVDKq",
          "input": {
            "nodeId": "BymvHVDF9",
            "pinKey": "Hyx8IS4vt9"
          },
          "output": {
            "nodeId": "S1b5BNwK9",
            "pinKey": "Sk1e_NIVE"
          }
        },
        "rJDUR4vKc": {
          "id": "rJDUR4vKc",
          "input": {
            "nodeId": "r1z8RNDYc",
            "pinKey": "HkXK-dGob"
          },
          "output": {
            "nodeId": "BymvHVDF9",
            "pinKey": "BJl-CEDY9"
          }
        },
        "BJPj5HvY5": {
          "id": "BJPj5HvY5",
          "input": {
            "nodeId": "rkXs9Hwtc",
            "pinKey": "HkXK-dGob"
          },
          "output": {
            "nodeId": "BymvHVDF9",
            "pinKey": "HkMY5HwK9"
          }
        },
        "SyIIavPK5": {
          "id": "SyIIavPK5",
          "input": {
            "nodeId": "BymvHVDF9",
            "pinKey": "rJ9Tjwwtq"
          },
          "output": {
            "nodeId": "ByBUawvK9",
            "pinKey": "ByfGSDjQE"
          }
        },
        "BJ_lsdPYq": {
          "id": "BJ_lsdPYq",
          "input": {
            "nodeId": "S14ls_DY5",
            "pinKey": "HkXK-dGob"
          },
          "output": {
            "nodeId": "BymvHVDF9",
            "pinKey": "rk41quPK9"
          }
        },
        "SkJ1GJqF5": {
          "id": "SkJ1GJqF5",
          "input": {
            "nodeId": "BymvHVDF9",
            "pinKey": "HkxV7udK5"
          },
          "output": {
            "nodeId": "ryJ4KCttq",
            "pinKey": "ByfGSDjQE"
          }
        },
        "rynyne5F9": {
          "id": "rynyne5F9",
          "input": {
            "nodeId": "Byrk2ecYc",
            "pinKey": "HkXK-dGob"
          },
          "output": {
            "nodeId": "BymvHVDF9",
            "pinKey": "rkU19lqY5"
          }
        },
        "B1h-Fint9": {
          "id": "B1h-Fint9",
          "input": {
            "nodeId": "BymvHVDF9",
            "pinKey": "BJkeFoht5"
          },
          "output": {
            "nodeId": "ry0Aksntc",
            "pinKey": "Sk1e_NIVE"
          }
        },
        "BJh8bSlcq": {
          "id": "BJh8bSlcq",
          "input": {
            "nodeId": "BymvHVDF9",
            "pinKey": "HyjZbBg59"
          },
          "output": {
            "nodeId": "BJLyWBe5c",
            "pinKey": "Bkf4BDsmV"
          }
        }
      },
      "comments": {
        "S1KdLudt5": {
          "content": "operating hours counter\n\nEN true = enable counting the time \nTrim can corrigate the timedrift i.e. when the counter counts to slow trim must be negativ ( - 1....10....) and vice versa\nADDR = Location from the internal eeprom to save and reload the elapsed time\nNSAVE = not save = trigger input to save the values when the MC powered off\nNSAFE = on = Power OK,--> off = save the data to eeprom (neg. edge evaluated)\nFor proper operation the MC power supply must buffered and the power is off input\nmust react fast\nCLEAR = erase the counted time",
          "id": "S1KdLudt5",
          "position": {
            "x": 2,
            "y": -1,
            "units": "slots"
          },
          "size": {
            "height": 3,
            "width": 15,
            "units": "slots"
          }
        }
      },
      "path": "@/example"
    },
    "@/operatinghourscounter": {
      "nodes": {
        "rkUIrEDt5": {
          "id": "rkUIrEDt5",
          "position": {
            "x": 6,
            "y": 2,
            "units": "slots"
          },
          "type": "xod/patch-nodes/not-implemented-in-xod"
        },
        "Hyx8IS4vt9": {
          "boundLiterals": {
            "__out__": "False"
          },
          "description": "Enable 'true' = counter count up the time",
          "label": "EN",
          "id": "Hyx8IS4vt9",
          "position": {
            "x": 6,
            "y": 1,
            "units": "slots"
          },
          "type": "xod/patch-nodes/input-boolean"
        },
        "BJl-CEDY9": {
          "description": "counted  seconds",
          "label": "S",
          "id": "BJl-CEDY9",
          "position": {
            "x": 10,
            "y": 3,
            "units": "slots"
          },
          "type": "xod/patch-nodes/output-number"
        },
        "HkMY5HwK9": {
          "description": "counted  minutes",
          "label": "M",
          "id": "HkMY5HwK9",
          "position": {
            "x": 9,
            "y": 3,
            "units": "slots"
          },
          "type": "xod/patch-nodes/output-number"
        },
        "rJ9Tjwwtq": {
          "description": "Trim can corrigate the timedrift\ni.e. when the counter counts to slow\ntrim must be negativ ( - 1....10....)\nand vice versa",
          "label": "TRIM",
          "id": "rJ9Tjwwtq",
          "position": {
            "x": 8,
            "y": 1,
            "units": "slots"
          },
          "type": "xod/patch-nodes/input-number"
        },
        "rk41quPK9": {
          "description": "counted  hours",
          "label": "H",
          "id": "rk41quPK9",
          "position": {
            "x": 8,
            "y": 3,
            "units": "slots"
          },
          "type": "xod/patch-nodes/output-number"
        },
        "HkxV7udK5": {
          "description": "Location from the internal eeprom\nto save and reload  the elapsed time",
          "label": "ADDR",
          "id": "HkxV7udK5",
          "position": {
            "x": 9,
            "y": 1,
            "units": "slots"
          },
          "type": "xod/patch-nodes/input-number"
        },
        "rkU19lqY5": {
          "description": "counted days",
          "label": "D",
          "id": "rkU19lqY5",
          "position": {
            "x": 7,
            "y": 3,
            "units": "slots"
          },
          "type": "xod/patch-nodes/output-number"
        },
        "BJkeFoht5": {
          "boundLiterals": {
            "__out__": "True"
          },
          "description": "nsave 'true' =  power  OK\nnsave 'false' = power off  ->                    counter values save to eeprom\n",
          "label": "NSAVE",
          "id": "BJkeFoht5",
          "position": {
            "x": 10,
            "y": 1,
            "units": "slots"
          },
          "type": "xod/patch-nodes/input-boolean"
        },
        "HyjZbBg59": {
          "label": "CLEAR",
          "id": "HyjZbBg59",
          "position": {
            "x": 11,
            "y": 1,
            "units": "slots"
          },
          "type": "xod/patch-nodes/input-pulse"
        }
      },
      "path": "@/operatinghourscounter",
      "attachments": [
        {
          "filename": "patch.cpp",
          "encoding": "utf8",
          "content": "#pragma XOD require \"https://github.com/dancojocaru2000/ArduinoEEPROM\"\n#include <EEPROM.h>\n\nnode { \nboolean saved ; // indicator for eeprom write done\nboolean zero ;\n    TimeMs nextTrig;\n    void evaluate(Context ctx) {\n        TimeMs tNow = transactionTime();\n  \n        auto addr = getValue<input_ADDR>(ctx);\n        auto trim = getValue<input_TRIM>(ctx);  \n        auto notsave = getValue<input_NSAVE>(ctx);\n       \n        TimeMs dt = 1000 + trim;\n        TimeMs tNext = tNow + dt;   \n        auto isEnabled = getValue<input_EN>(ctx);\n\n\n//------------------------------------------------------------------------------------------------------------\n// clear the operatinghourscounter to zero\n       if (isInputDirty<input_CLEAR>(ctx))  {                                       \n              uint16_t eeaddr = addr;  \n               uint8_t countm = 0;\n               uint8_t counth = 0;\n                         zero = true; // countervalues will cleared zo zero\n  EEPROM.write(eeaddr,countm);  // write minutes to eeprom\n       \n    eeaddr += 1;\n        \n    EEPROM.write(eeaddr,counth); // write hours to eeprom\n\n      uint16_t countvalue = 0;\n      byte  lowbyte = 0;\n     byte  highbyte = 0;    \n    word hlbyte = 0;\n    hlbyte =  word(countvalue);\n                    \n    lowbyte =(( hlbyte) & 0x00FF);\n    highbyte =((hlbyte >> 8) & 0xFF);  \n     eeaddr = addr;    \n    eeaddr += 2;\n         \n    EEPROM.write(eeaddr,lowbyte);  // write days lowbyte to eeprom\n       \n    eeaddr += 1;\n        \n    EEPROM.write(eeaddr,highbyte);  // write days highbyte to eeprom\n  \n          \n            \n        }\n\n\n\n        \n//-------------------------------------------------------------------------------------------------------------      \n// reload the counter of minutes, hours and days after power on  (seconds dont care)    \n        \n        if  ((isSettingUp())|| ((zero) == true)){    // triggers reading of minutes, hours and days value from eeprom            \n            uint16_t eeaddr = addr; \n        auto result = EEPROM.read(eeaddr);      // low byte = minutes, high byte = hours\n        byte lowbyte = result;\n       \n            eeaddr +=1;\n             result = EEPROM.read(eeaddr);\n        byte highbyte = result;  \n\n              emitValue<output_S>(ctx,0);\n              \n              uint8_t countm = ((lowbyte << 0) & 0x00FF) ; \n \n              emitValue<output_M>(ctx, countm);      \n \n              uint8_t counth =  ((highbyte << 0) & 0x00FF); \n \n              emitValue<output_H>(ctx, counth);      \n\n            \n              eeaddr +=1;  \n              result = EEPROM.read(eeaddr);    // low and highbyte = word = days\n              lowbyte = result;  \n       \n              eeaddr +=1;\n              result = EEPROM.read(eeaddr);\n              highbyte = result;  \n \n\n              Number countd = ((lowbyte << 0) & 0x00FF) + ((highbyte << 8) & 0xFF00); \n              emitValue<output_D>(ctx, countd);\n\n              zero = false;\n        \n        }\n        \n//------------------------------------------------------------------------------------------------------------\n\n/* write the counter data in the eeprom befor power breaks down\nuse an input to detect power off and buffer the mc with an suitable capacitor */\n        \n       if ((notsave) == true) {\n           saved = false;\n       }\n      \n        if  ( ( notsave) == false &&(saved) == false)  {       \n            uint8_t countm = getValue<output_M>(ctx);\n            uint8_t counth = getValue<output_H>(ctx);\n            Number countd = getValue<output_D>(ctx);\n           \n            byte lowbyte = countm;         \n            byte highbyte = counth;            \n            uint16_t eeaddr = addr;    \n   \n    EEPROM.write(eeaddr,lowbyte);  // write minutes to eeprom\n       \n    eeaddr += 1;\n        \n    EEPROM.write(eeaddr,highbyte); // write hours to eeprom\n\n      uint16_t countvalue = countd;\n        lowbyte = 0;\n       highbyte = 0;    \n    word hlbyte = 0;\n    hlbyte =  word(countvalue);\n                    \n    lowbyte =(( hlbyte) & 0x00FF);\n    highbyte =((hlbyte >> 8) & 0xFF);  \n     eeaddr = addr;    \n    eeaddr += 2;\n         \n    EEPROM.write(eeaddr,lowbyte);  // write days lowbyte to eeprom\n       \n    eeaddr += 1;\n        \n    EEPROM.write(eeaddr,highbyte);  // write days highbyte to eeprom\n    saved = true;          //after values saved in the eeprom variable 'saved' = true\n        }\n//-------------------------------------------------------------------------------------------------------\n        \n        if (isTimedOut(ctx) && isEnabled) {\n\n            uint8_t counts = getValue<output_S>(ctx);\n            uint8_t countm = getValue<output_M>(ctx);\n            uint8_t counth = getValue<output_H>(ctx);\n            Number countd = getValue<output_D>(ctx);\n            boolean ovh =false;\n            counts += 1 ; // seconds\n    if    (counts > 59) {\n            counts = 0;\n             countm +=1;} //minutes\n             \n    if    (countm > 59) { \n           countm = 0;\n           counth +=1; //hours \n  if (counth > 23) {\n     counth = 0;   \n    countd += 1;\n   }\n\n    }  \n                     \n \n       nextTrig = tNext;\n            setTimeout(ctx, dt);  \n           \n            emitValue<output_S>(ctx, counts);\n            emitValue<output_M>(ctx, countm);\n            emitValue<output_H>(ctx, counth);\n            emitValue<output_D>(ctx, countd);      \n       }\n            if (nextTrig < tNow || nextTrig > tNext) {\n                // Start timeout from scratch\n                nextTrig = tNext;\n                setTimeout(ctx, dt);\n        }\n    \n    }\n\n  }\n\n//________________________________________________________________________\n\n\n\n        \n        \n \n\n\n"
        }
      ]
    }
  },
  "license": "AGL",
  "version": "0.1.0",
  "description": "counts the time when the EN input is true saves the counted time to eeprom if power off",
  "name": "workingtimecounter"
}
